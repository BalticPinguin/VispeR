<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>functions_smsc.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id="background"></div>
<div id='container'>
  <div class='section'>
    <div class='docs'><h1>functions_smsc.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <p>filename: functions_smsc.py</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">glob</span> <span class="o">,</span> <span class="nn">re</span> <span class="o">,</span> <span class="nn">shutil</span> <span class="o">,</span> <span class="nn">mmap</span> <span class="o">,</span><span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">logging</span><span class="o">,</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>for python-3 compatibility</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="nb">open</span> 
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span> <span class="c"># for function sort(). Probably find a better function!!</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <p>include <a href="Btree.html">Btree.py</a></p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">Btree</span> <span class="kn">as</span> <span class="nn">bt</span> <span class="c">#class of binary tree</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>Below are the conversion factors and fundamental constant</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="n">AMU2au</span><span class="o">=</span><span class="mf">1822.88839</span>                                          
<span class="n">Angs2Bohr</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">0.52917721092</span>                                  
<span class="n">Hartree2GHz</span><span class="o">=</span><span class="mf">6.579684e6</span>                                     
<span class="n">Hartree2cm_1</span><span class="o">=</span><span class="mf">219474.63</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">quantity</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
   <span class="n">F</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span> 
   <span class="n">CartCoord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
   <span class="n">X</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
   <span class="n">P</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
   <span class="n">Energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">F</span><span class="p">,</span> <span class="n">CartCoord</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Energy</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      <p>This function is a self-writen sort-function for floats-arrays</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">f</span><span class="p">):</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <p>(increasing arguments by absolute value). Its input is the array whose elements 
should not exceed 3e300 (otherwise the sorting will fails) and returns the number 
of indices sorted by the size of respective elements. Hence, sorting an array A
by the size of its elemens (largest first) can be done by 
index=sort(A) 
B=A[index]
where B will be the sorted array.
For not absolute values see resort()."""
index=np.zeros( len(f), dtype=int ) 
tmp=deepcopy(f) #for avoiding side effects
for i in range(len(f)):
   index[i]=np.argmin(np.abs(tmp)) # there can be frequencies &lt; 0 as well...
   tmp[index[i]]=3e+300 # this can be considered as smaller than all elements...
return index</p>
<p>resort(f): #only temporary of interest
This function is a self-writen sort-function for floats-arrays (increasing</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="n">arguments</span> <span class="ow">not</span> <span class="n">absolute</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span> <span class="n">Its</span> <span class="nb">input</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">array</span> <span class="n">whose</span> <span class="n">elements</span> <span class="n">should</span> 
   <span class="ow">not</span> <span class="n">exceed</span> <span class="mf">3e300</span> <span class="p">(</span><span class="n">otherwise</span> <span class="n">the</span> <span class="n">sorting</span> <span class="n">will</span> <span class="n">fails</span><span class="p">)</span> <span class="ow">and</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">indices</span> 
   <span class="nb">sorted</span> <span class="n">by</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">respective</span> <span class="n">elements</span><span class="o">.</span> <span class="n">Hence</span><span class="p">,</span> <span class="n">sorting</span> <span class="n">an</span> <span class="n">array</span> <span class="n">A</span> <span class="n">by</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">its</span> 
   <span class="n">elemens</span> <span class="p">(</span><span class="n">largest</span> <span class="n">first</span><span class="p">)</span> <span class="n">can</span> <span class="n">be</span> <span class="n">done</span> <span class="n">by</span> 
   <span class="n">index</span><span class="o">=</span><span class="n">sort</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
   <span class="n">B</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
   <span class="n">where</span> <span class="n">B</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="nb">sorted</span> <span class="n">array</span><span class="o">.</span>
   <span class="n">For</span> <span class="n">sorting</span> <span class="n">of</span> <span class="n">absolute</span> <span class="n">values</span> <span class="n">see</span> <span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">   index=np.zeros( len(f), dtype=int ) </span>
<span class="s">   tmp=deepcopy(f) #for avoiding side effects</span>
<span class="s">   for i in range(len(f)):</span>
<span class="s">      index[i]=np.argmin(tmp) </span>
<span class="s">      tmp[index[i]]=3e+300 # this can be considered as smaller than all elements...</span>
<span class="s">   return index</span>
<span class="s">#DIVIDER</span>
<span class="s">def gs(A):</span>
<span class="s">#DIVIDER</span>
<span class="s">   def proj(v1, v2):</span>
<span class="s">      return map(lambda x : x *(np.dot(v2,</span>
<span class="s">   	       v1) / np.dot(v1, v1)) , v1)</span>

<span class="s">   X=A.T # I want to orthogonalize row-wise</span>
<span class="s">   Y = []</span>
<span class="s">   for i in range(len(X)):</span>
<span class="s">      temp_vec = X[i]</span>
<span class="s">      for inY in Y :</span>
<span class="s">	 proj_vec = proj(inY, X[i])</span>
<span class="s">	 temp_vec = map(lambda x, y : x - y, temp_vec, proj_vec)</span>
<span class="s">      a=np.sqrt(sum(temp_vec[j]*temp_vec[j] for j in range(len(temp_vec)) )) #calculate norm</span>
<span class="s">      Y.append( temp_vec/a) #normalize all vectors</span>
<span class="s">   return np.matrix(Y).T # undo transposition in the beginning</span>
<span class="s">#DIVIDER</span>
<span class="s">def replace(files, freq, L):</span>
<span class="s">#DIVIDER</span>
<span class="s">   freq*=Hartree2cm_1</span>
<span class="s">   for i in range(len(files)):</span>
<span class="s">      with open(files[i][0]) as f:</span>
<span class="s">	 out_fname = files[i][0] + &quot;.rep&quot;</span>
<span class="s">	 out = open(out_fname, &quot;w&quot;)</span>
<span class="s">	 s=0</span>
<span class="s">	 t=0</span>
<span class="s">	 u=-3</span>
<span class="s">	 for line in f:</span>
<span class="s">	    if re.search(r&#39;Frequencies -- [\d .-]+&#39;, line) is not None:</span>
<span class="s">	       t=0 #reset t, when frequencies occur</span>
<span class="s">	       u+=3 #</span>
<span class="s">	       logging.debug(&#39;frequencies not yet written to file:&#39;+ repr(len(freq[i][s:].T))+ repr(freq[i][s:].T))</span>
<span class="s">	       if len(freq[i][s:].T)&gt; 2: # there are at least three more frequencies</span>
<span class="s">		  out.write(re.sub(r&#39;Frequencies -- [\d .-]+&#39;,</span>
<span class="s">		       	&#39;Frequencies --&#39;+&#39;    &#39;+repr(freq[i][s])+&#39;          &#39;</span><span class="se">\</span>
<span class="s">			+repr(freq[i][s+1])+&#39;          &#39;+repr(freq[i][s+2]), line))</span>
<span class="s">	       elif len(freq[i][s:].T)== 2: # there are only two frequencies left</span>
<span class="s">		  out.write(re.sub(r&#39;Frequencies -- [\d .-]+&#39;,</span>
<span class="s">			&#39;Frequencies --&#39;+&#39;     &#39;+repr(freq[i][s])+&#39;          &#39;</span><span class="se">\</span>
<span class="s">			+repr(freq[i][s+1]), line))</span>
<span class="s">	       elif len(freq[i][s:].T)== 1: # there is just one additional freq</span>
<span class="s">		  out.write(re.sub(r&#39;Frequencies -- [\d .-]+&#39;,</span>
<span class="s">			&#39;Frequencies --&#39;+&#39;    &#39;+repr(freq[i][s]), line))</span>
<span class="s">	       s+=3</span>
<span class="s">	    elif re.search(r&#39;[ ]+\d+[ ]+\d+[ -]+\d.\d\d[ -]+\d.\d\d+[ \d.-]+&#39;, line) is not None:</span>
<span class="s">	       logging.debug(&#39;number of modes left:&#39;+ repr(len(L[i][t][u:].T)))</span>
<span class="s">	       if len(L[i][t][u:].T)&gt; 2: # there are at least three more frequencies</span>
<span class="s">		  out.write(re.sub(r&#39;[\d .-]+&#39;, &#39;    &#39;+repr(t/3)+&#39;    &#39;+repr(s)+&#39;   &#39;+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+0])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+0])+&#39; &#39;+</span>
<span class="s">		  	   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+0])+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+1])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+1])+&#39; &#39;+</span>
<span class="s">			   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+1])+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+2])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+2])+&#39; &#39;+</span>
<span class="s">			   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+2]), line))</span>
<span class="s">	       elif len(L[i][t][u:].T)== 2:</span>
<span class="s">		  out.write(re.sub(r&#39;[\d .-]+&#39;, &#39;    &#39;+repr(t/3)+&#39;    &#39;+repr(s)+&#39;   &#39;+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+0])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+0])+&#39; &#39;+</span>
<span class="s">			   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+0])+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+1])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+1])+&#39; &#39;+</span>
<span class="s">			   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+1]), line))</span>
<span class="s">	       elif len(L[i][t][u:].T)== 1:</span>
<span class="s">		  out.write(re.sub(r&#39;[\d .-]+&#39;, &#39;    &#39;+repr(t/3)+&#39;    &#39;+repr(s)+&#39;   &#39;+</span>
<span class="s">		     &#39;   &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t][u+0])+&#39;  &#39;+str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+1][u+0])+&#39; &#39;+</span>
<span class="s">			   str(&quot;</span><span class="si">%.2f</span><span class="s">&quot; % L[i][t+2][u+0]), line))</span>
<span class="s">	       t+=3 # </span>
<span class="s">	    else: </span>
<span class="s">	       out.write(re.sub(&#39;replace nothing&#39;,&#39;by nothing&#39;, line)) #just write line as it is</span>
<span class="s">	 out.close()</span>
<span class="s">#DIVIDER</span>
<span class="s">def gaussianfreq(ContntInfo, dim):</span>
<span class="s">#DIVIDER</span>
<span class="s">   f=np.zeros((len(ContntInfo), dim-6))</span>
<span class="s">   for i in range(len(ContntInfo)): </span>
<span class="s">      files=open(ContntInfo[i][0], &quot;r&quot;) #open file and map it for better working</span>
<span class="s">      mapedlog=mmap.mmap(files.fileno(), 0, prot=mmap.PROT_READ) # i-th file containing freq calculations</span>
<span class="s">      files.close</span>
<span class="s">      f1=re.findall(r&quot; Frequencies -- [\d .-]+&quot;, mapedlog, re.M)# </span>
<span class="s">      f2=[re.findall(r&quot;[- ]\d+.\d+&quot;, f1[j]) for j in range(len(f1))]</span>
<span class="s">      s=0</span>
<span class="s">      for j in range(len(f2)):</span>
<span class="s">	 f[i][s:s+len(f2[j])]=f2[j]</span>
<span class="s">	 s+=len(f2[j])</span>
<span class="s">   return f</span>
<span class="s">#DIVIDER</span>
<span class="s">def extractL(ContntInfo, dim):</span>
<span class="s">   for i in range(len(ContntInfo)): </span>
<span class="s">      files=open(ContntInfo[i][0], &quot;r&quot;) #open file and map it for better working</span>
<span class="s">      mapedlog=mmap.mmap(files.fileno(), 0, prot=mmap.PROT_READ) # i-th file containing freq calculations</span>
<span class="s">      files.close</span>
<span class="s">      f1=re.findall(r&quot; Atom  AN [</span><span class="se">\n</span><span class="s">\d XYZ.-]+&quot;, mapedlog, re.M)</span>
<span class="s">      mapedlog.close() </span>
<span class="s">      Ltemp=[re.findall(r&quot;[- ]\d.\d\d&quot;, f1[j]) for j in range(len(f1))]</span>
<span class="s">      assert len(Ltemp)&gt;=0, &#39;PROGRAMM ERROR: file&#39;+repr(ContntInfo[i][0])+ </span><span class="se">\</span>
<span class="s">	       &#39; does not contain frequency informations.</span><span class="se">\</span>
<span class="s">	       This should have been avoided above already.&#39;</span>
<span class="s">      if i==0:</span>
<span class="s">	 L2=np.zeros((len(ContntInfo),dim,dim-6)) # similar to L</span>
<span class="s">      for k in range(len(Ltemp)): # </span>
<span class="s">	 for j in range(len(Ltemp[k])): </span>
<span class="s">	    L2[i][j%3+(j/9)*3][(j/3)%3+3*k]=Ltemp[k][j]</span>
<span class="s">      for k in range(len(L2[i][0])): #renormalization</span>
<span class="s">	 L2[i][:].T[k]/=np.sqrt(np.sum( L2[i][:].T[k]*L2[i][:].T[k]))</span>
<span class="s">   return L2</span>
<span class="s">#DIVIDER</span>
<span class="s">def TrafoCoord(F, P, Coord, dim):</span>
<span class="s">#DIVIDER</span>
<span class="s">   Y=np.zeros((dim,dim)) </span>
<span class="s">   one=np.eye(dim)</span>
<span class="s">   S=np.zeros((3,3))</span>
<span class="s">   for i in range(3):</span>
<span class="s">      for j in range(3):</span>
<span class="s">	 S[i][j]=np.dot(Coord[0][i],Coord[1][j])</span>
<span class="s">      S[i]/=np.linalg.norm(S[i])</span>
<span class="s">   print &#39;Overlapmatrix of coordinates:</span><span class="se">\n</span><span class="s">&#39;, S</span>
<span class="s">   for i in range(3):</span>
<span class="s">      for j in range(3):</span>
<span class="s">	 S[i][j]=round(S[i][j])</span>
<span class="s">   print &#39;rounded overlapmatrix:</span><span class="se">\n</span><span class="s">&#39;, S</span>
<span class="s">   Coord[1]=np.dot(S,Coord[1])</span>
<span class="s">   for j in range(dim/3):</span>
<span class="s">      Y[3*j:3*j+3].T[3*j:3*j+3]=S</span>
<span class="s">#DIVIDER</span>
<span class="s">   logging.debug( &#39;new Coords</span><span class="se">\n</span><span class="s">&#39;+ repr(S)+&#39;</span><span class="se">\n</span><span class="s">&#39;+repr(Y))</span>
<span class="s">   F[1]=np.dot(np.dot(Y.T,F[1]),Y)</span>
<span class="s">#DIVIDER</span>
<span class="s">   P[1]=one-np.dot(np.dot(Y.T,one-P[1]),Y) #for second file: D -&gt; YD (Y.T: redirect of axes)</span>
<span class="s">#DIVIDER</span>
<span class="s">   return F, P, Coord</span>
<span class="s">#DIVIDER</span>
<span class="s">def Contentcheck(inputs): #look through it in detail! In the way it is, it is senseless!!</span>
<span class="s">#DIVIDER</span>
<span class="s">   ContntInfo=[] #create array: name(char), Stoichiometry(char), root(int), freq(bool),</span>
<span class="s">#DIVIDER</span>
<span class="s">   for files in inputs:</span>
<span class="s">      name= files</span>
<span class="s">      log=open(name, &quot;r&quot;) #open file and map it for better working</span>
<span class="s">      mapedlog=mmap.mmap(log.fileno(), 0, prot=mmap.PROT_READ) # improve by finding a better size</span>
<span class="s">      log.close</span>
<span class="s">      stoi=re.findall(r&quot;[\w]+&quot; ,re.findall(r&quot;-+</span><span class="se">\n</span><span class="s"> [\w \d]+</span><span class="se">\n</span><span class="s"> -+</span><span class="se">\n</span><span class="s"> Charge =&quot;, mapedlog, re.I)[0])[0]</span>
<span class="s">      freq=re.search(r&quot;-+</span><span class="se">\n</span><span class="s"> \#[\w\d\- \)\(\/=</span><span class="se">\n</span><span class="s">]+</span><span class="se">\</span>
<span class="s">	    freq [\w\d \)\(\/=\-</span><span class="se">\n</span><span class="s">]+</span><span class="se">\n</span><span class="s"> -+&quot;,</span>
<span class="s">	    mapedlog, re.M) is not None #I hope, this is reasonable</span>
<span class="s">      freq=re.search(r&quot; freq &quot;, mapedlog, re.I) is not None #I hope, this is reasonable</span>
<span class="s">      if freq is True:</span>
<span class="s">	 if (re.search(r&quot; Error termination&quot;, mapedlog) is None) is True: #if successful calculations were done</span>
<span class="s">	    ContntInfo.extend([[name, stoi]]) #write into array all information about files</span>
<span class="s">	 else:</span>
<span class="s">	    logging.error(&quot;Some error occured. In file &quot;+</span><span class="se">\</span>
<span class="s">		     name + &quot;. It seems as if the calculation did not end correctly. Please check the log-file.&quot;)</span>
<span class="s">   Contnt=ContntInfo</span>
<span class="s">   return Contnt</span>
<span class="s">#DIVIDER</span>
<span class="s">def ReadLog(fileN):</span>
<span class="s">#DIVIDER</span>
<span class="s">   files=open(fileN, &quot;r&quot;)</span>
<span class="s">   log=mmap.mmap(files.fileno(), 0, prot=mmap.PROT_READ)</span>
<span class="s">   files.close</span>
<span class="s">#DIVIDER</span>
<span class="s">   atmwgt=re.findall(r&quot;AtmWgt= [\d .]+&quot;,log)</span>
<span class="s">   mtemp=[]</span>
<span class="s">   foonum=0</span>
<span class="s">   for j in range(len(atmwgt)/2): # because atomic masses are printed twize in log-files...</span>
<span class="s">      mtemp.append(re.findall(r&#39;[\d.]+&#39;,atmwgt[j]))</span>
<span class="s">   dim=0</span>
<span class="s">   for j in range(len(mtemp)):</span>
<span class="s">	 dim+=len(mtemp[j]) # dim will be sum over all elements of temp</span>
<span class="s">   dim*=3</span>
<span class="s">   mass=np.zeros(dim/3) # this is an integer since dim=3*N with N=atomicity</span>
<span class="s">   for j in range(len(mtemp)):</span>
<span class="s">      for k in range(len(mtemp[j])):</span>
<span class="s">	 mass[k+foonum]=np.sqrt(float(mtemp[j][k])*AMU2au) #elements in m are sqrt(m_i) where m_i is the i-th atoms mass</span>
<span class="s">      foonum+=len(mtemp[j])</span>
<span class="s">   logging.debug(&quot;atmwgt: &quot;+ repr(atmwgt)+&#39;</span><span class="se">\n</span><span class="s">mtemp: &#39;+ repr(mtemp))</span>
<span class="s">   logging.info(&quot;Number of atoms: &quot;+ repr(dim/3)+&#39;</span><span class="se">\n</span><span class="s">Dimensions of a problem: &#39;+</span><span class="se">\</span>
<span class="s">	 repr(dim)+&#39;Sqrt of masses in a.u. as read from log file</span><span class="se">\n</span><span class="s">&#39;+ repr(mass))</span>
<span class="s">#DIVIDER</span>
<span class="s">   temp=[]</span>
<span class="s">   temp=re.findall(r&#39; Number     Number       Type             X           Y           Z[</span><span class="se">\n</span><span class="s"> -.\d]+&#39;, log)</span>
<span class="s">   tmp=re.findall(r&#39;[ -][\d]+.[\d]+&#39;, temp[-1])</span>
<span class="s">   assert len(tmp)==dim, &#39;Not all atoms were found! Something went wrong...&#39;</span>
<span class="s">   Coord=np.zeros((3, dim/3))</span>
<span class="s">   MassCenter=np.zeros(3)</span>
<span class="s">   for j in range(len(tmp)):</span>
<span class="s">      Coord[j%3][j/3]=tmp[j]</span>
<span class="s">   for j in range(3):</span>
<span class="s">      MassCenter[j]=np.sum(Coord[j]*mass)</span>
<span class="s">      MassCenter[j]/=np.sum(mass) #now it is cartesian center of mass</span>
<span class="s">   logging.debug(&quot;Cartesian (Angstrom) coordinates before alignment to center of mass</span><span class="se">\n</span><span class="s">&quot;+ repr(Coord.T)+</span><span class="se">\</span>
<span class="s">	 &quot;Center of mass coordinates (Angstrom)</span><span class="se">\n</span><span class="s">&quot;+ repr(MassCenter))</span>
<span class="s">   for j in range(3):#displacement of molecule into center of mass:</span>
<span class="s">      Coord[j]-=MassCenter[j] # if commented we get rotational constants in agreement with Gaussian log</span>
<span class="s">   logging.debug(&quot;Cartesian coords with respect to center of mass</span><span class="se">\n</span><span class="s">&quot;+ repr(Coord.T))</span>
<span class="s">   Coord*=Angs2Bohr</span>
<span class="s">   logging.info(&quot;Cartesian coordinates (a.u.) in center of mass system</span><span class="se">\n</span><span class="s">&quot;+repr(Coord.T))</span>
<span class="s">#DIVIDER</span>
<span class="s">   moi=np.zeros((3,3))# this is Moment Of Inertia</span>
<span class="s">#DIVIDER</span>
<span class="s">   for j in range(3):</span>
<span class="s">      for k in range(3):</span>
<span class="s">	 if k is j:</span>
<span class="s">	    moi[j][k]=np.sum(mass*mass*(Coord[0]*Coord[0]+</span><span class="se">\</span>
<span class="s">		     Coord[1]*Coord[1]+Coord[2]*Coord[2]-</span><span class="se">\</span>
<span class="s">		     Coord[j]*Coord[k]))</span>
<span class="s">	 else:</span>
<span class="s">	    moi[j][k]=np.sum(mass*mass*(Coord[j]*Coord[k]))</span>
<span class="s">   logging.debug(&quot;Moments of intertia as read from log file</span><span class="se">\n</span><span class="s">&quot;+repr(moi))</span>
<span class="s">   diagI,X=np.linalg.eig(moi) # this can be shortened of course!</span>
<span class="s">   index=sort(diagI)</span>
<span class="s">#DIVIDER</span>
<span class="s">   X=np.matrix(X) #sorting by eigenvalues</span>
<span class="s">   diagI=diagI[index]</span>
<span class="s">   logging.debug(&quot;Moments of inertia (a.u.) in principle axes</span><span class="se">\n</span><span class="s">&quot;+repr(diagI.T)+</span><span class="se">\</span>
<span class="s">	 &#39;</span><span class="se">\n</span><span class="s">Rotational constants (GHz) in principle axes</span><span class="se">\n</span><span class="s">&#39;+ repr(1/(2*diagI.T)*Hartree2GHz)+</span><span class="se">\</span>
<span class="s">      &quot;Rotation matrix</span><span class="se">\n</span><span class="s">&quot;+repr(X))</span>
<span class="s">#DIVIDER</span>
<span class="s">   f=re.findall(r&quot;Force constants in Cartesian coordinates: [</span><span class="se">\n</span><span class="s">\d .+-D]+&quot;, log, re.M)</span>
<span class="s">   f_str=str(f)[2:-2]</span>
<span class="s">   lines=f_str.strip().split(&quot;</span><span class="se">\\</span><span class="s">n&quot;)</span>
<span class="s">   F=np.zeros((dim,dim))</span>
<span class="s">   n=0</span>
<span class="s">   k=0</span>
<span class="s">   for i in range(2,len(lines)):</span>
<span class="s">      if i == dim+k-5*n+2: # is &#39;is&#39; ok as well?</span>
<span class="s">         k=i-1</span>
<span class="s">         n+=1</span>
<span class="s">         continue</span>
<span class="s">      elements=lines[i].replace(&#39;D&#39;,&#39;e&#39;).split()</span>
<span class="s">      for j in range(1,len(elements)):</span>
<span class="s">         F[int(elements[0])-1][j-1+5*n]=float(elements[j])</span>
<span class="s">         F[j-1+5*n][int(elements[0])-1]=float(elements[j])</span>
<span class="s">   logging.debug(&#39;F matrix as read from log file</span><span class="se">\n</span><span class="s">&#39;+ repr(F) +&#39;</span><span class="se">\n</span><span class="s">0:9x0:9</span><span class="se">\n</span><span class="s">&#39;+ repr(F[:9].T[:9].T))</span>
<span class="s">   for i in range(0,dim):</span>
<span class="s">      for j in range(0,dim):</span>
<span class="s">         F[i][j]/= (mass[i/3]*mass[j/3]) </span>

<span class="s">   Etemp=re.findall(r&#39;HF=-[\d.</span><span class="se">\n</span><span class="s"> ]+&#39;, log, re.M)</span>
<span class="s">   assert len(Etemp)&gt;=1, &#39;Some error occured! The states energy can not be read.&#39;</span>
<span class="s">   if re.search(r&#39;</span><span class="se">\n</span><span class="s"> &#39;, Etemp[-1]) is not None:</span>
<span class="s">      Etemp[-1]=Etemp[-1].replace(&quot;</span><span class="se">\n</span><span class="s"> &quot;, &quot;&quot;) </span>
<span class="s">   logging.info(&#39;temporary energy of state:&#39;+repr(Etemp[-1]))</span>
<span class="s">   E=-float(re.findall(r&#39;[\d.]+&#39;, Etemp[-1])[0])# energy is negative (bound state)</span>
<span class="s">   return dim, Coord, mass, X, F, E</span>
<span class="s">#DIVIDER</span>
<span class="s">def GetProjector(X, dim, m, Coord):</span>
<span class="s">   D=np.zeros((dim,6))</span>
<span class="s">   for k in range(3):# first three rows in D: The translational vectors</span>
<span class="s">      for j in range(dim/3):</span>
<span class="s">	 D[3*j+k][k]=m[j]</span>
<span class="s">   for k in range(dim):# next three rows in D: The rotational vectors</span>
<span class="s">      D[k][3:6]=(np.cross(np.dot(X,Coord)[:].T[k/3],X[:].T[k%3]))*m[k/3]</span>

<span class="s">   logging.debug(&quot;Original translational and rotational displacement vectors&quot;+repr(D[3:13].T))</span>
<span class="s">   AOE=gs(np.array(D)) #orhogonalize it</span>
<span class="s">   ones=np.identity(dim)</span>
<span class="s">   one_P=ones-np.dot(AOE,AOE.T)</span>
<span class="s">   prob_vec=(AOE.T[1]+AOE.T[4]+AOE.T[0]+AOE.T[5]).T #what is this actually??</span>
<span class="s">   assert not np.any(np.abs(prob_vec-np.dot(np.dot(AOE,AOE.T),prob_vec))&gt;0.00001), </span><span class="se">\</span>
<span class="s">	    &#39;Translations and rotations are affected by projection operator.&#39;+</span><span class="se">\</span>
<span class="s">	    repr(np.abs(prob_vec-np.dot(np.dot(AOE,AOE.T),prob_vec)))</span>
<span class="s">   assert not  np.any(np.abs(np.dot(one_P,prob_vec))&gt;0.00001), </span><span class="se">\</span>
<span class="s">	    &quot;Projecting out translations and rotations from probe vector&quot;</span>
<span class="s">   return one_P</span>
<span class="s">#DIVIDER</span>
<span class="s">def GetL(dim, mass, F, D):</span>
<span class="s">#DIVIDER</span>
<span class="s">   L=np.zeros(( len(F), len(F[0]), len(F[0])-6 )) </span>
<span class="s">   N=np.zeros(( len(F), len(F[0]), len(F[0]) )) </span>
<span class="s">   Lsorted=np.zeros(( len(F), len(F[0]), len(F[0])-6 )) </span>
<span class="s">   f=np.zeros(( len(F), len(F[0])-6 ))</span>
<span class="s">   Ltemp=np.zeros(( len(F[0]), len(F[0])-6 ))</span>
<span class="s">   ftemp=np.zeros(len(F[0]-6))</span>
<span class="s">   for i in range(len(F)): #temporary for understanding only (this loop)</span>
<span class="s">      ftemp,Ltemp=np.linalg.eig(F[i])</span>
<span class="s">      index=sort(np.real(ftemp)) # ascending sorting f</span>
<span class="s">      N[i]=Ltemp[index]</span>
<span class="s">      foo=ftemp[index]</span>
<span class="s">      logging.debug(&quot;Before projecting onto internal coords subspace:</span><span class="se">\n</span><span class="s">&quot;+ &#39;Forces:</span><span class="se">\n</span><span class="s">&#39;+</span><span class="se">\</span>
<span class="s">	    repr(F[i])+&#39;</span><span class="se">\n</span><span class="s">Frequencies (cm-1) </span><span class="se">\n</span><span class="s">&#39;+ repr(np.sqrt(np.abs(ftemp[index]))*Hartree2cm_1)+</span><span class="se">\</span>
<span class="s">            &quot;</span><span class="se">\n</span><span class="s">L-matrix </span><span class="se">\n</span><span class="s">&quot;+ repr(N[i]))</span>

<span class="s">   for i in range(len(F)):</span>
<span class="s">      ftemp,Ltemp=np.linalg.eig(np.dot(np.dot(D[i].T,F[i]),D[i]))</span>
<span class="s">#DIVIDER</span>
<span class="s">      index=sort(np.real(ftemp)) # ascending sorting f</span>
<span class="s">      f[i]=np.real(ftemp[index]).T[:].T[6:].T</span>
<span class="s">      L[i]=np.real(Ltemp[index]).T[:].T[6:].T # or =Ltemp[index].T (see above)</span>
<span class="s">      logging.debug(&quot;Frequencies (cm-1) </span><span class="se">\n</span><span class="s">&quot;+ repr(np.sqrt(np.abs(ftemp[index]))*Hartree2cm_1))</span>
<span class="s">#DIVIDER</span>
<span class="s">      N[i]=np.real(Ltemp[index]) # or =Ltemp[index].T (see above)</span>
<span class="s">      M=np.zeros((dim,dim))</span>
<span class="s">      for j in range(0,dim):</span>
<span class="s">         M[j,j]=1/mass[j/3]</span>
<span class="s">      Lcart=np.dot(M,np.dot(D[i],np.real(Ltemp)))</span>
<span class="s">      for j in range(0,dim):</span>
<span class="s">         norm=np.sum(Lcart.T[j]*Lcart.T[j])</span>
<span class="s">	 if np.abs(norm)&gt;1e-12:</span>
<span class="s">	    Lcart.T[j]/=np.sqrt(norm)</span>
<span class="s">      Lsorted[i]=(Lcart.T[index].T)[:].T[6:].T</span>
<span class="s">      index=resort(f[i]) # only of temporary interest!! .......</span>
<span class="s">      bar=L[i] #...............................................</span>
<span class="s">      L[i]=bar[:].T[index].T #.................................</span>
<span class="s">      bar=Lsorted[i] #.........................................</span>
<span class="s">      Lsorted[i]=bar[:].T[index].T #...........................</span>
<span class="s">      bar=f[i] #...............................................</span>
<span class="s">      f[i]=bar[index] #........................................</span>
<span class="s">      logging.debug(&quot;Normalized Lcart</span><span class="se">\n</span><span class="s">&quot;+ repr(Lcart)+&quot;</span><span class="se">\n</span><span class="s">Normalized, sorted and truncated Lcart</span><span class="se">\n</span><span class="s">&quot;+ repr(Lsorted[i]))</span>

<span class="s">      for j in range(len(f[i])):</span>
<span class="s">     	 f[i][j]=np.sign(f[i][j])*np.sqrt(np.abs(f[i][j]))</span>
<span class="s">      logging.info(&quot;After projecting onto internal coords subspace</span><span class="se">\n</span><span class="s">&quot;+&quot;Frequencies (cm-1)</span><span class="se">\n</span><span class="s">&quot;+</span><span class="se">\</span>
<span class="s">	    repr(f[i]*Hartree2cm_1)+&quot;L-matrix </span><span class="se">\n</span><span class="s">&quot;+ repr(L[i]))</span>
<span class="s">   return N, L, f, Lsorted</span>
<span class="s">#DIVIDER</span>
<span class="s">def GetL1(dim, mass, F, G09f, P):</span>
<span class="s">#DIVIDER</span>
<span class="s">   np.set_printoptions(suppress=True)</span>
<span class="s">   np.set_printoptions(precision=2, linewidth=122)</span>
<span class="s">#DIVIDER</span>
<span class="s">   def InvIteration(F,L,Lambda): #inverse iteration to find better modes</span>
<span class="s">      ones=np.eye(len(F))</span>
<span class="s">      for i in range(len(L)):</span>
<span class="s">	 for j in range(len(ones)): #there is no built-in for scalar*matrix</span>
<span class="s">	    ones[j][j]*=Lambda[i]</span>
<span class="s">	 print len(F),&#39; &#39;, len(F[0]),&#39;  &#39;,len(ones),&#39;  &#39;,len(ones[0])</span>
<span class="s">	 A=np.matrix(F-ones)</span>
<span class="s">	 print A</span>
<span class="s">	 print len(A),&#39; &#39;,len(A[0]),&#39;  &#39;, len(L),&#39; &#39;,len(L[0]),&#39;  &#39;,len(Lambda)</span>
<span class="s">	 print np.linalg.cond(A) #this eigenvalue is close to the exact one; hence no </span>
<span class="s">	 if np.linalg.cond(A)&gt;10000: #this eigenvalue is close to the exact one; hence no </span>
<span class="s">	    break                   #optimization is needed (and not possible)</span>
<span class="s">	 A_1=np.linalg.inv(A)       # is this sufficient numerically stable?</span>
<span class="s">	 tmp=L[i]-L[i]</span>
<span class="s">	 while np.linalg.norm(tmp-L[i])&gt;0.00001/len(L[i]): #this should be a reasonable threshold</span>
<span class="s">	    tmp=L[i]</span>
<span class="s">#DIVIDER</span>
<span class="s">	    L[i]=np.dot(A_1,L[i].T).T/np.linalg.norm(A_1.dot(L[i].T))</span>
<span class="s">      return L</span>

<span class="s">   logging.info(&quot;Len(F) is &quot;+repr(len(F)))</span>
<span class="s">#DIVIDER</span>
<span class="s">   L=np.zeros(( len(F), len(F[0]), len(F[0])-6 )) </span>
<span class="s">   Lsorted=np.zeros(( len(F), len(F[0]), len(F[0])-6 )) </span>
<span class="s">   f=np.zeros(( len(F), len(F[0])-6 ))</span>
<span class="s">   Ltemp=np.zeros(( len(F[0]), len(F[0])-6 ))</span>
<span class="s">   ftemp=np.zeros(len(F[0]-6))</span>
<span class="s">   for i in range(len(F)):</span>
<span class="s">      ftemp,Ltemp=np.linalg.eig(np.dot(np.dot(P[i].T,F[i]),P[i]))</span>
<span class="s">#DIVIDER</span>
<span class="s">      index=sort(np.real(ftemp)) # ascending sorting f</span>
<span class="s">      f[i]=np.real(ftemp[index]).T[:].T[6:].T</span>
<span class="s">      L[i]=np.real(Ltemp[index]).T[:].T[6:].T # or =Ltemp[index].T (see above)</span>
<span class="s">      logging.debug(&quot;Frequencies (cm-1) </span><span class="se">\n</span><span class="s">&quot;+ repr(np.sqrt(np.abs(ftemp[index]))*Hartree2cm_1))</span>
<span class="s">#DIVIDER</span>
<span class="s">      print np.dot(np.dot(P[i].T,F[i]),P[i])</span>
<span class="s">      print f[i]</span>
<span class="s">      print L[i]</span>
<span class="s">      L[i]=InvIteration(np.dot(np.dot(P[i].T,F[i]),P[i]), L[i], G09f[i]) #&#39;repair&#39; L-matrix (truncated)</span>
<span class="s">      M=np.zeros((dim,dim))</span>
<span class="s">      for j in range(0,dim):</span>
<span class="s">         M[j,j]=1/mass[j/3]</span>
<span class="s">      Lcart=np.dot(M,np.dot(P[i],np.real(Ltemp)))</span>
<span class="s">      for j in range(0,dim):</span>
<span class="s">         norm=np.sum(Lcart.T[j]*Lcart.T[j])</span>
<span class="s">	 if np.abs(norm)&gt;1e-12:</span>
<span class="s">	    Lcart.T[j]/=np.sqrt(norm)</span>
<span class="s">      Lsorted[i]=(Lcart.T[index].T)[:].T[6:].T</span>
<span class="s">      index=resort(f[i]) # only of temporary interest!! .......</span>
<span class="s">      bar=L[i] #...............................................</span>
<span class="s">      L[i]=bar[:].T[index].T #.................................</span>
<span class="s">      bar=Lsorted[i] #.........................................</span>
<span class="s">      Lsorted[i]=bar[:].T[index].T #...........................</span>
<span class="s">      bar=f[i] #...............................................</span>
<span class="s">      f[i]=bar[index] #........................................</span>
<span class="s">      logging.debug(&quot;Normalized Lcart</span><span class="se">\n</span><span class="s">&quot;+ repr(Lcart)+&quot;</span><span class="se">\n</span><span class="s">Normalized, sorted and truncated Lcart</span><span class="se">\n</span><span class="s">&quot;+ repr(Lsorted[i]))</span>

<span class="s">      for j in range(len(f[i])):</span>
<span class="s">     	 f[i][j]=np.sign(f[i][j])*np.sqrt(np.abs(f[i][j]))</span>
<span class="s">      logging.info(&quot;After projecting onto internal coords subspace</span><span class="se">\n</span><span class="s">&quot;+&quot;Frequencies (cm-1)</span><span class="se">\n</span><span class="s">&quot;+</span><span class="se">\</span>
<span class="s">	    repr(f[i]*Hartree2cm_1)+&quot;L-matrix </span><span class="se">\n</span><span class="s">&quot;+ repr(L[i]))</span>
<span class="s">   return L, f, Lsorted  #attention! The frequencies are NOT stabilized...</span>
<span class="s">#DIVIDER</span>
<span class="s">def Geometries(ContntInfo, problems):</span>
<span class="s">   name=[]</span>
<span class="s">   geometry=[] # will contain names of the files refering to different states</span>
<span class="s">   coordName=[]</span>
<span class="s">   coordNumb=[]</span>
<span class="s">   geometry.append(ContntInfo[0][0])</span>
<span class="s">   for i in range(len(ContntInfo)):  #loop over all states investigated</span>
<span class="s">      files=open(ContntInfo[i][0], &quot;r&quot;)#open file and map it for better working</span>
<span class="s">      mapedlog=mmap.mmap(files.fileno(), 0, prot=mmap.PROT_READ)</span>
<span class="s">      files.close</span>
<span class="s">      coords=re.findall(</span>
<span class="s">	    r&quot; ! Name  Definition[ ]+Value[]+Derivative Info.[ ]+![!,()RADEXcalutenyi\d /=</span><span class="se">\n</span><span class="s"> .-]+&quot;,</span>
<span class="s">	    mapedlog, re.I)</span>
<span class="s">      if len(coords)==0:</span>
<span class="s">#DIVIDER</span>
<span class="s">	    print &quot;in file &quot;+ContntInfo[i][0]+&#39; are no coordinate-informations&#39;</span>
<span class="s">	    continue</span>
<span class="s">      mapedlog.close()</span>
<span class="s">      coordName.append(re.findall(r&quot; [RAD]{1}\([\d,]+\)&quot;, coords[-1]))</span>
<span class="s">      coordNumb.append(re.findall(r&quot; \d+.\d+&quot;, coords[-1]))</span>
<span class="s">      check=np.zeros(len(coordName)-1)</span>
<span class="s">      if i==0:</span>
<span class="s">         for k in range(len(coordName[0])):</span>
<span class="s">            coordNumb[0][k]=float(coordNumb[0][k])</span>
<span class="s">      for j in range(len(coordName)-1):  #loop over all previously investigated files</span>
<span class="s">         if len(coordName[j]) != len(coordName[i]): #if number of coordinates doesn&#39;t mach</span>
<span class="s">	    check[j]+=1</span>
<span class="s">	    continue</span>
<span class="s">	 for k in range(len(coordName[j])):</span>
<span class="s">	    if coordName[j][k] != coordName[i][k]: ##here an error occurs!!!!</span>
<span class="s">#DIVIDER</span>
<span class="s">	       check[j]+=1</span>
<span class="s">	       continue</span>
<span class="s">	    coordNumb[-1][k]=float(coordNumb[i][k])</span>
<span class="s">	    if np.abs(coordNumb[-1][k])&lt;0.1: #avoid dividing by 0</span>
<span class="s">	       if np.abs(coordNumb[j][k]-coordNumb[-1][k])&gt;3:</span>
<span class="s">		  check[j]+=1</span>
<span class="s">		  continue</span>
<span class="s">	    elif np.abs(</span>
<span class="s">		  (coordNumb[j][k]-coordNumb[-1][k])</span>
<span class="s">		  /coordNumb[-1][k])&gt;0.04: #difference more than 4%</span>
<span class="s">	       check[j]+=1</span>
<span class="s">	       continue</span>
<span class="s">      if np.all(check &gt; 0):</span>
<span class="s">	 geometry.append(ContntInfo[i][0])</span>
<span class="s">   return geometry</span>
<span class="s">#DIVIDER</span>
<span class="s">def Duschinsky(N, L, mass, dim, x):</span>
<span class="s">   J=np.zeros((dim-6,dim-6))</span>
<span class="s">   FF=np.zeros((len(L),dim,dim))</span>
<span class="s">   K=np.zeros(dim-6)</span>
<span class="s">   I=np.zeros((len(L),dim))</span>
<span class="s">   M=np.zeros((dim,dim)) #this is a diagonal matrix</span>
<span class="s">   for i in range(dim):</span>
<span class="s">      M[i][i]=mass[i/3] #square root of masses</span>
<span class="s">   DeltaX=np.zeros((len(L),dim))</span>
<span class="s">   for i in range(len(DeltaX[0])/3):</span>
<span class="s">      DeltaX[0][3*i:3*i+3]=x[0].T[i]</span>
<span class="s">   J=np.dot(L[0].T, np.linalg.pinv(L[1].T)) #always relaxation into ground state</span>

<span class="s">   np.set_printoptions(suppress=True)</span>
<span class="s">   np.set_printoptions(precision=3, linewidth=138)</span>
<span class="s">   print&#39;Duschinsky</span><span class="se">\n</span><span class="s">&#39;,  J</span>
<span class="s">   print </span>

<span class="s">   DeltaX=np.array(x[0]-x[1]).flatten(&#39;F&#39;)</span>
<span class="s">   logging.debug(&#39;Flatted</span><span class="se">\n</span><span class="s">&#39;+repr(DeltaX))</span>
<span class="s">#DIVIDER</span>
<span class="s">   K=np.dot(L[1].T,DeltaX.T)</span>
<span class="s">   one=np.eye(len(FF[0]))</span>
<span class="s">   logging.info(&#39;Duschinsky rotation matrix, &#39;+</span><span class="se">\</span>
<span class="s">	 repr(np.linalg.norm(J[1]-np.eye(dim-6))/(dim-6))+ &#39;  :</span><span class="se">\n</span><span class="s">&#39;+ repr(J)+</span><span class="se">\</span>
<span class="s">	 &#39;  :</span><span class="se">\n</span><span class="s">&#39;+ repr(J[:4].T[11:25])+</span><span class="se">\</span>
<span class="s">	 &#39;</span><span class="se">\n</span><span class="s">Duschinsky displacement vector:</span><span class="se">\n</span><span class="s">&#39;+ repr(K))</span>
<span class="s">   return J, K #J[0] is unity (if not everything goes wrong), second is of interenst...</span>
<span class="s">#DIVIDER</span>
<span class="s">def HuangR(K, f): #what is with different frequencies???</span>
<span class="s">#DIVIDER</span>
<span class="s">   unif=np.zeros(len(K))</span>
<span class="s">   multif=np.zeros(len(K))</span>
<span class="s">   logging.info(&#39;Delta Q:&#39;+repr( K))</span>
<span class="s">   unif=K*K*f[1]/(2)</span>
<span class="s">   multif=K*K*f[0]*f[0]/(2*f[1])</span>
<span class="s">   index=sort(multif)</span>
<span class="s">   sortmulti=multif[index]</span>
<span class="s">   sortfI=f[1][index]</span>
<span class="s">   sortfF=f[0][index]</span>
<span class="s">   index=sort(unif)</span>
<span class="s">   sortuni=unif[index]</span>
<span class="s">   funi=f[1][index]</span>
<span class="s">   if any(multif)&lt;0:</span>
<span class="s">      logging.warning(&#39;ATTENTION: some HR-factors are &lt;0 for different frequencies in ground- and excited state.</span><span class="se">\</span>
<span class="s">	    In the following their absolute value is used.&#39;)</span>
<span class="s">   if any(unif)&lt;0:</span>
<span class="s">      logging.warning(&#39;ATTENTION: some HR-factors are &lt;0 if coinciding frequencies are assumed.</span><span class="se">\</span>
<span class="s">	    In the following their absolute value is used.&#39;)</span>
<span class="s">   for j in range(len(unif)):</span>
<span class="s">#DIVIDER</span>
<span class="s">      s=1</span>
<span class="s">#DIVIDER</span>
<span class="s">   return sortuni, funi, sortmulti, sortfI, sortfF</span>
<span class="s">#DIVIDER</span>
<span class="s">def unifSpect(intens, E, freq, N, M):</span>
<span class="s">#DIVIDER</span>
<span class="s">   logging.debug(&#39;Spectrum</span><span class="se">\n</span><span class="s">&#39;+ repr(N)+&#39; &#39;+repr(M)+&#39;  &#39;+repr(len(intens))+&#39;  &#39;+repr(len(intens[0])))</span>
<span class="s">   spect=np.zeros((2,len(intens)*len(freq)))</span>
<span class="s">   for x in range(N):</span>
<span class="s">      for a in range(len(freq)):</span>
<span class="s">	 spect[1][x*len(freq)+a]=sum(intens[x+i][i] for i in range( int(min(M,N-x))) ) #not correct at the moment??</span>
<span class="s">	 spect[0][x*len(freq)+a]=(E-freq[a]*x)*Hartree2cm_1</span>
<span class="s">   for x in range(1,M):</span>
<span class="s">      for a in range(len(freq)):</span>
<span class="s">	 spect[1][x*len(freq)+a]=sum(intens[i][x+i] for i in range( int(min(N,M-x))) ) #not correct at the moment??</span>
<span class="s">	 spect[0][x*len(freq)+a]=(E+freq[a]*x)*Hartree2cm_1</span>
<span class="s">   return spect</span>
<span class="s">#DIVIDER</span>
<span class="s">def calcspect(HR, freq, E, N, M):</span>
<span class="s">#DIVIDER</span>

<span class="s">#DIVIDER</span>
<span class="s">   def occOPA(dim, N, M):</span>
<span class="s">      Xi_g=np.zeros((dim,M*dim))</span>
<span class="s">      Xi_e=np.zeros((dim,N*dim))</span>
<span class="s">      for i in range(dim):</span>
<span class="s">	 for j in range(M):</span>
<span class="s">	    Xi_g[i][i+j]=j+1</span>
<span class="s">	 for j in range(N):</span>
<span class="s">	    Xi_e[i][i+j]=j+1</span>
<span class="s">      return Xi_g, Xi_e</span>
<span class="s">#DIVIDER</span>
<span class="s">   def FCeqf( Deltag, M, N):</span>
<span class="s">      exg=np.exp(-np.abs(Deltag)/2) #actually Deltag should be &gt;0, but is not always due to negative frequencies</span>
<span class="s">      faktNM=math.factorial(M)*math.factorial(N)</span>
<span class="s">      FC=0</span>
<span class="s">      for x in range(int(min(N,M))+1):</span>
<span class="s">	 FC+=exg*math.pow(-1,N-x)*math.pow(np.abs(Deltag),(M+N-2*x)//2)/(math.factorial(M-x)*math.factorial(N-x))*</span><span class="se">\</span>
<span class="s">	       math.sqrt(faktNM/(math.factorial(x)*math.factorial(x)))</span>
<span class="s">      return FC</span>
<span class="s">   </span>
<span class="s">   </span>
<span class="s">   Xi_g, Xi_e=occOPA(len(HR), N, M)</span>
<span class="s">   intens=np.ones((len(Xi_e[0]), len(Xi_g[0]))) #matrix consisting of 1 </span>
<span class="s">   FC=np.zeros((len(Xi_g),len(Xi_e[0]), len(Xi_g[0]))) #general for other approximations as well</span>
<span class="s">   for i in range(len(Xi_g)):</span>
<span class="s">      FC00=FCeqf(HR[i], 0, 0)</span>
<span class="s">      for j in range(len(Xi_g[i])):</span>
<span class="s">      	 for k in range(len(Xi_e[i])):</span>
<span class="s">   	    if Xi_g[i][j]==0 and  Xi_e[i][k]==0: #this saves time at least if OPA is taken into account</span>
<span class="s">	       FC[i][k][j]=FC00</span>
<span class="s">	    else:</span>
<span class="s">	       FC[i][k][j]=FCeqf(HR[i], Xi_g[i][j], Xi_e[i][k])</span>
<span class="s">   for i in range(len(FC)):</span>
<span class="s">      intens=intens*FC[i] #proportional to square of FC factors &gt;FC is already the sqare of overlap-integral</span>
<span class="s">   spect=unifSpect(intens, E, freq, len(Xi_e[0]), len(Xi_g[0]))</span>
<span class="s">   return spect</span>
<span class="s">#DIVIDER</span>
<span class="s">def FCf(J, K, f, Energy, N):</span>
<span class="s">#DIVIDER</span>
<span class="s">   def CalcI00(J, K, Gamma, Gammap, E):</span>
<span class="s">#DIVIDER</span>
<span class="s">      invJ=np.linalg.inv(J)</span>
<span class="s">      pref=math.pow(2,len(Gamma))*np.linalg.det(Gamma)</span>
<span class="s">      TMP=J.dot(invJ.dot(Gammap).dot(J)+Gamma)</span>
<span class="s">      pref/=np.linalg.det(TMP)</span>
<span class="s">#DIVIDER</span>
<span class="s">      pref=np.sqrt(pref)</span>
<span class="s">      TMP=invJ.dot(Gammap).dot(J)+Gamma</span>
<span class="s">      TMP=Gammap.dot(J).dot(np.linalg.inv(TMP)).dot(invJ)-np.eye(len(J))</span>
<span class="s">      exp=np.exp(0.5*K.T.dot(TMP).dot(Gammap).dot(K))</span>

<span class="s">      L=bt.Tree(2*len(K))</span>
<span class="s">      L.fill(0)</span>
<span class="s">      Zero=np.zeros(2*len(K))</span>
<span class="s">      L.insert(Zero, [pref*exp, (E+sum(sum(Gammap-Gamma))/2)*Hartree2cm_1] ) #sum(sum()) due to matrix</span>
<span class="s">      for alpha in range(len(K)):</span>
<span class="s">	 linspect.append(L.extract()) #I_00 transition</span>
<span class="s">      return L</span>

<span class="s">   Gamma=np.diag(f[0]) #in atomic units. It is equivalent to 4pi^2/h f_i</span>
<span class="s">   Gammap=np.diag(f[1]) # for final state</span>

<span class="s">   linspect=[] #intensities</span>
<span class="s">   L2=CalcI00(J, K, Gamma, Gammap, Energy)</span>
<span class="s">   print &#39;state0 is ready&#39;</span>
<span class="s">   L1=L2 #for first state this is ok</span>
<span class="s">   for i in range(1,N+1):</span>
<span class="s">      L1, L2=iterate(L1, L2, Energy, i, f, J,K)</span>
<span class="s">      linspect.append(L2.extract)  </span>
<span class="s">   return linspect #2-dimensional array</span>
<span class="s">#DIVIDER</span>
<span class="s">def iterate(L1, L2, Energy, i, f, J, K):</span>
<span class="s">#DIVIDER</span>

<span class="s">#DIVIDER</span>
<span class="s">   Gamma=np.diag(f[0])              # in atomic units. It is equivalent to 4pi^2/h f_i</span>
<span class="s">   Gammap=np.diag(f[1])             # for final state</span>
<span class="s">   sqGamma=np.diag(np.sqrt(f[0]))   </span>
<span class="s">   sqGammap=np.diag(np.sqrt(f[1]))  </span>
<span class="s">   unity=np.eye(len(Gamma))</span>
<span class="s">   invJ=np.linalg.inv(J)</span>

<span class="s">   C=np.linalg.inv(invJ.dot(Gammap).dot(J)+Gamma) #C is only temporary matrix here</span>
<span class="s">   A=np.dot(J,np.dot(C,invJ)) </span>
<span class="s">   A=2*np.dot(Gammap,np.dot(J,A))-unity</span>
<span class="s">   b=unity-J.dot(C).dot(invJ).dot(Gammap)</span>
<span class="s">   b=2*sqGammap.dot(unity-b).dot(K)</span>
<span class="s">   E=4*sqGamma.dot(C).dot(invJ).dot(sqGammap)</span>
<span class="s">   d=-2*sqGamma.dot(C).dot(invJ).dot(Gammap).dot(K)</span>
<span class="s">   C=2*Gamma.dot(C)-unity #this is &#39;real&#39; C-matrix</span>
<span class="s">#DIVIDER</span>
<span class="s">   alpha=2*len(b)</span>
<span class="s">   L3=bt.Tree(i)           # initialize root-node</span>
<span class="s">   L3.fill(alpha)          # initialize tree</span>
<span class="s">   States=states(alpha, i) # States are all possible</span>
<span class="s">#DIVIDER</span>
<span class="s">   def freq(E, Gamma, Gammap):</span>
<span class="s">	return (E+sum(Gammap-Gamma))*Hartree2cm_1</span>
<span class="s">#DIVIDER</span>
<span class="s">   def FirstNonzero(n):</span>
<span class="s">#DIVIDER</span>
<span class="s">      ni=n[len(n)//2:] #interger division (python3-compatible)</span>
<span class="s">      nf=n[:len(n)//2]</span>
<span class="s">      m=len(ni)+1 #this means there is no excitation in this state</span>
<span class="s">      mp=len(nf)+1</span>
<span class="s">      for j in range(len(ni)):</span>
<span class="s">	 if ni[j]&gt;0:</span>
<span class="s">	    m=j</span>
<span class="s">	    break</span>
<span class="s">      for j in range(len(nf)):</span>
<span class="s">	 if nf[j]&gt;0:</span>
<span class="s">	    mp=j</span>
<span class="s">	    break</span>
<span class="s">      return m, mp</span>
<span class="s">   for n in States: #for each possible state, described by n(vector)</span>
<span class="s">      m, mp= FirstNonzero(n)# index of first-non-zero element of (initial, final) state</span>
<span class="s">#DIVIDER</span>
<span class="s">      I_nn=0</span>
<span class="s">      if m&lt;=mp:</span>
<span class="s">	 n_m=n[m]</span>
<span class="s">	 ntemp=deepcopy(n)</span>
<span class="s">	 ntemp[m]-=1 #n[m] is at least 1</span>
<span class="s">#DIVIDER</span>
<span class="s">	 Ps=L2.getState(ntemp)[0]</span>
<span class="s">     	 if not math.isnan(Ps):</span>
<span class="s">	    I_nn=b[m]*Ps					# first term </span>
<span class="s">	 if ntemp[m]&gt;0:</span>
<span class="s">	    ntemp[m]-=1</span>
<span class="s">	    Ps=L1.getState(ntemp)[0]</span>
<span class="s">	    if not math.isnan(Ps):</span>
<span class="s">	       I_nn+=np.sqrt(2*(n_m-1))*A[m][m]*Ps		# second term</span>
<span class="s">	 for i in range(m+1, len(n)/2):</span>
<span class="s">	    if n[i]&gt;0:</span>
<span class="s">	       ntemp=deepcopy(n)</span>
<span class="s">	       ntemp[m]-=1</span>
<span class="s">	       ntemp[i]-=1</span>
<span class="s">	       Ps=L1.getState(ntemp)[0]</span>
<span class="s">	       if not math.isnan(Ps):</span>
<span class="s">		  I_nn+=np.sqrt(n[i]/2)*(A[m][i]+A[i][m])*Ps	# second term</span>
<span class="s">	 for i in range(mp+len(n)//2, len(n)): 			#sum over respective final states</span>
<span class="s">	    if n[i]&gt;0:</span>
<span class="s">	       ntemp=deepcopy(n)</span>
<span class="s">	       ntemp[m]-=1</span>
<span class="s">	       ntemp[i]-=1</span>
<span class="s">	       Ps=L1.getState(ntemp)[0]</span>
<span class="s">	       if not math.isnan(Ps):</span>
<span class="s">		  I_nn+=np.sqrt(n[i]/2)*(E[i-len(n)//2][m])*Ps		# second term</span>
<span class="s">#DIVIDER</span>
<span class="s">      else: </span>
<span class="s">	 n_m=n[mp]</span>
<span class="s">	 ntemp=deepcopy(n)</span>
<span class="s">	 ntemp[mp]-=1</span>
<span class="s">	 Ps=L2.getState(ntemp)[0]</span>
<span class="s">     	 if not math.isnan(Ps):</span>
<span class="s">   	    I_nn=d[mp]*Ps					# first term </span>
<span class="s">	 if ntemp[m]&gt;0:</span>
<span class="s">	    ntemp[mp]-=1</span>
<span class="s">	    Ps=L1.getState(ntemp)[0]</span>
<span class="s">	    if not math.isnan(Ps):</span>
<span class="s">	       I_nn+=np.sqrt(2*(n_m-1))*C[mp][mp]*Ps          	# second term</span>
<span class="s">	 for i in range(mp+1, len(n)):</span>
<span class="s">	    if n[i]&gt;0:</span>
<span class="s">	       ntemp=deepcopy(n)</span>
<span class="s">	       ntemp[mp]-=1</span>
<span class="s">	       ntemp[i]-=1</span>
<span class="s">	       Ps=L1.getState(ntemp)[0]</span>
<span class="s">	       if not math.isnan(Ps):</span>
<span class="s">		  I_nn+=np.sqrt(n[i]/2)*(C[mp][i-len(n)//2]+    # second term</span>
<span class="s">			   C[i-len(n)//2][mp])*Ps	</span>
<span class="s">	 for i in range(mp, len(n)): 				#sum over respective final states</span>
<span class="s">	    if n[i]&gt;0:</span>
<span class="s">	       ntemp=deepcopy(n)</span>
<span class="s">	       ntemp[mp]-=1</span>
<span class="s">	       ntemp[i]-=1</span>
<span class="s">	       Ps=L1.getState(ntemp)[0]</span>
<span class="s">	       if not math.isnan(Ps):</span>
<span class="s">		  I_nn+=np.sqrt(n[i]/2)*(E[mp][i-len(n)//2])*Ps 		# second term</span>
<span class="s">      I_nn/=np.sqrt(2*n_m)</span>
<span class="s">      L3.insert(n, [I_nn, freq(Energy, f[0]*n[:len(n)//2], f[1]*n[len(n)//2:]) ])</span>
<span class="s">   print L3.extract()</span>
<span class="s">   return L2, L3</span>
<span class="s">#DIVIDER</span>
<span class="s">def outspect(spectfile, gridpt, linspect, gamma):</span>
<span class="s">#DIVIDER</span>
<span class="s">      These functions are part of python-package: &#39;combinatorics&#39; </span>
<span class="s">      (download from https://pypi.python.org/pypi/Combinatorics)</span>
<span class="s">      unlabeled_balls_in_labeled_boxes(balls, box_sizes): This function </span>
<span class="s">      returns a generator that produces all distinct distributions of indistinguishable balls</span>
<span class="s">      among labeled boxes with specified box sizes (capacities). This is </span>
<span class="s">      a generalization of the most common formulation of the problem, where each box is</span>
<span class="s">      sufficiently large to accommodate all of the balls, and is an important </span>
<span class="s">      example of a class of combinatorics problems called &#39;weak composition&#39; problems.</span>
<span class="s">   </span>
<span class="s">      OVERVIEW</span>
<span class="s">   </span>
<span class="s">      This function returns a generator that produces all distinct distributions of</span>
<span class="s">      indistinguishable balls among labeled boxes with specified box sizes</span>
<span class="s">      (capacities).  This is a generalization of the most common formulation of the</span>
<span class="s">      problem, where each box is sufficiently large to accommodate all of the</span>
<span class="s">      balls, and is an important example of a class of combinatorics problems</span>
<span class="s">      called &#39;weak composition&#39; problems.</span>
<span class="s">   </span>
<span class="s">   </span>
<span class="s">      CONSTRUCTOR INPUTS</span>
<span class="s">   </span>
<span class="s">      n: the number of balls</span>
<span class="s">      </span>
<span class="s">      box_sizes: This argument is a list of length 1 or greater.  The length of</span>
<span class="s">      the list corresponds to the number of boxes.  `box_sizes[i]` is a positive</span>
<span class="s">      integer that specifies the maximum capacity of the ith box.  If</span>
<span class="s">      `box_sizes[i]` equals `n` (or greater), the ith box can accommodate all `n`</span>
<span class="s">      balls and thus effectively has unlimited capacity.</span>
<span class="s">   </span>
<span class="s">   </span>
<span class="s">      ACKNOWLEDGMENT</span>
<span class="s">   </span>
<span class="s">      I&#39;d like to thank Chris Rebert for helping me to convert my prototype</span>
<span class="s">      class-based code into a generator function.</span>
<span class="s">#DIVIDER</span>
<span class="s">	 This recursive generator function was designed to be returned by</span>
<span class="s">	 `unlabeled_balls_in_labeled_boxes`.</span>
<span class="s">#DIVIDER</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      <p>code for Gram-Schmidt adapted from iizukak, see https://gist.github.com/iizukak/1287876
This function does row-wise Gram-Schmidt orthonormalization of matrices.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <p>The code is originally from stevaha (http://stackoverflow.com/questions/1597649/replace-strings-in-files-by-python)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      <p>This function creates a new file (determined by files, ending with</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <p>.rep" and copies the log-file (files) into it, replacing the frequencies and 
ormal modes by those calculated by smallscript.
he function is suited to test, whether these results coincide qualitatively with the gaussian's.
<em> Arguments: </em>*
.  <br />
. <br />
.   </p>
<p>o return-statements (results are written to file)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      <p>Extraction of the frequencies from g09-log file</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-13'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-13'>#</a>
      </div>
      <p>extracting the L-matrix from the log file for comparing with the one calculated above</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-14'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-14'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-15'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-15'>#</a>
      </div>
      <p>assuming two files !! (more are impossible here...)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-16'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-16'>#</a>
      </div>
      <p>Returning the read values</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-17'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-17'>#</a>
      </div>
      <p>print P[1]
the following seems to have problems!!</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-18'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-18'>#</a>
      </div>
      <p>print P[1]</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-19'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-19'>#</a>
      </div>
      <p>This function opens the given g09-log files and checks, whether frequency-calculations are done and if they converged. Otherwise these states are not taken into account.
The function is valid for any number of files.</p>
<p>Arguments:
1.</p>
<p>returns:
A list containing the file-names and calculation-names (of g09) of successfull frequency-calculations</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-20'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-20'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-21'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-21'>#</a>
      </div>
      <p>for files in glob.glob('*.log'):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-22'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-22'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-23'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-23'>#</a>
      </div>
      <p>Mapping the log file</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-24'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-24'>#</a>
      </div>
      <p>Determine atomic masses in a.u. Note mass contains sqrt of mass!!!</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-25'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-25'>#</a>
      </div>
      <p>Reading Cartesian coordinates</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-26'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-26'>#</a>
      </div>
      <p>Getting tensor of inertia, transforming to principlas axes</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-27'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-27'>#</a>
      </div>
      <p>print Coord[1]</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-28'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-28'>#</a>
      </div>
      <p>X=np.matrix(X[index]) #sorting by eigenvalues</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-29'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-29'>#</a>
      </div>
      <p>Reading of Cartesian force constant matrix  </p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-30'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-30'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-31'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-31'>#</a>
      </div>
      <p>Function that calculates the frequencies and normal modes from force constant matrix</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-32'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-32'>#</a>
      </div>
      <p>ith and without projection onto internal degrees of freedom</p>
<p><em>argumets</em>*
. The dimensions of force-constant matrix
. square-root of masses dim/3-dimensional array
. force-constant matrix
. projection-matrix onto vibrations</p>
<p><em>return</em>*
. matrix of all normal modes (including global modes) 
. matrix of vibr. normal modes (including global modes) 
. frequencies 
. massweighted L for comparison with the respective matrix from the g09 log-file</p>
<p>Defining arrays</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-33'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-33'>#</a>
      </div>
      <p>assert np.any(ftemp&lt;0) or np.imag(ftemp)!=0, 'Frequencies smaller than 0 occured. Please check the input-file!!'</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-34'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-34'>#</a>
      </div>
      <p>assert any(ftemp&lt;0), 'negative frequencies occured. Please check the geometry!'</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-35'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-35'>#</a>
      </div>
      <p>Function that calculates the frequencies and normal modes from force constant matrix</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-36'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-36'>#</a>
      </div>
      <p>ith projection onto internal degrees of freedom and uses inverse iteration to get 
umerically better results for normal modes. Therefore the g09-frequencies are used</p>
<p><em>argumets</em>*
. The dimensions of force-constant matrix
. square-root of masses dim/3-dimensional array
. force-constant matrix
. dim-6-dimensional array of frequencies calculated by g09
. projection-matrix onto vibrations</p>
<p><em>return</em>*
. matrix of vibr. normal modes (including global modes) 
. frequencies 
. massweighted L for comparison with the respective matrix from the g09 log-file</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-37'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-37'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-38'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-38'>#</a>
      </div>
      <p>ERROR: elements not aligned</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-39'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-39'>#</a>
      </div>
      <p>Defining arrays</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-40'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-40'>#</a>
      </div>
      <p>assert np.any(ftemp&lt;0) or np.imag(ftemp)!=0, 'Frequencies smaller than 0 occured. Please check the input-file!!'
'repair' L-matrix using G09-frequencies</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-41'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-41'>#</a>
      </div>
      <p>assert any(ftemp&lt;0), 'negative frequencies occured. Please check the geometry!'</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-42'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-42'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-43'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-43'>#</a>
      </div>
      <p>problems.append()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-44'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-44'>#</a>
      </div>
      <p>print coordName[j][k]+' '+coordName[i][k]</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-45'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-45'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-46'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-46'>#</a>
      </div>
      <p>for j in range(len(DeltaX[0])/3):
DeltaX[i][3<em>j:3</em>j+3]=DeltaX[0][3<em>j:3</em>j+3]-x[i].T[j]
K[i]=np.dot(L[i].T,np.dot(M,DeltaX.T))</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-47'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-47'>#</a>
      </div>
      <p>Function that calculates the Huang-Rhys factors for all vibrational states</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-48'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-48'>#</a>
      </div>
      <p><em>Arguments</em>*
. The displacements of minima in internal coordinates
. The frequencies of respective modes</p>
<p><em>returns</em>*
eturn sortuni, funi, sortmulti, sortfG, sortfE
. HR-factors for coinciding frequencies sorted by size (decreasing)
. respective frequencies for 1. (same order)
. HR-factors for different frequencies of involved electronic states sorted by size (decreasing)
. respecivp frequencies of initial state for 3 (same order)
. respecivp frequencies of final state for 3 (same order)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-49'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-49'>#</a>
      </div>
      <p>if aoe[-j]&gt;0.2: 
print 'multi_freq:',sortfG[-j]<em>Hartree2cm_1,'  ',sortfE[-j]</em>Hartree2cm_1,'  ' , sortmulti[-j]</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-50'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-50'>#</a>
      </div>
      <p>print('uni_freq:',funi[-j]*Hartree2cm_1,'  ', sortuni[-j])</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-51'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-51'>#</a>
      </div>
      <p>Calculation of the line spectrum respecting only shift of minima (no Duschinsky rotation)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-52'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-52'>#</a>
      </div>
      <p>nd assuming coinciding frequencies for initial and final state</p>
<p><em>Arguments</em>*
. array of intensities of transitions
. diffenece of ground-state energy difference of the electronic states involved
. array of frequencies of the respected states
. maximum number of allowed excitations in initial mode
. maximum number of allowed excitations in final mode</p>
<p><em>returns</em>*
 2-dimensional array with energies of transition (1. column) and their rate (2. column)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-53'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-53'>#</a>
      </div>
      <p>This is used to calculate the line spectrum assuming no mode mixing (shift only) and coinciding frequencies in both electronic states.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-54'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-54'>#</a>
      </div>
      <p>Arguments:
1. Huang-Rhys factors
2. frequencies (have to be in the same order as HR
3. energy difference of energy surfaces
4, 5. N and M are the numbers of vibrational quanta can be in the modes
All arguments are neccesary.</p>
<p>returns:</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-55'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-55'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-56'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-56'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-57'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-57'>#</a>
      </div>
      <p>Calculates the FC-factors for given Duschinsky-effect. No restriction to OPA</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-58'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-58'>#</a>
      </div>
      <p><em>Arguments</em>:
1.  Duschinsky-rotation matrix
2.  Displacement-Vector
3.  frequency: two-dim array (freq_initial, freq_final)
4.  Energy-difference of minima
5.  Max. number of excitation quanta state considered</p>
<p>All arguments are obligatory.
<em>returns</em>:
linespectrum </p>
<p>This function calculates the overlap-integral for no vibrations</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-59'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-59'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-60'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-60'>#</a>
      </div>
      <p>error!!!! This has to be positive but is not always!!</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-61'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-61'>#</a>
      </div>
      <p>Calculates the Franck-Condon factors of ... using the lower levels L1 and L2</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-62'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-62'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-63'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-63'>#</a>
      </div>
      <p>quantities for the iterative spectrum-calculation</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-64'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-64'>#</a>
      </div>
      <p>initialize new tree</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-65'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-65'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-66'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-66'>#</a>
      </div>
      <p>Find first non-zero elements in first and second half of array n</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-67'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-67'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-68'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-68'>#</a>
      </div>
      <p>if the 'first' excited state is in initial state: need first iteration formula</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-69'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-69'>#</a>
      </div>
      <p>print L2.getState(ntemp)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-70'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-70'>#</a>
      </div>
      <p>else: need the other iteration-formula</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-71'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-71'>#</a>
      </div>
      <p>This function calculates the broadened spectrum given the line spectrum, frequency-rage and output-file whose name is first argument.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-72'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-72'>#</a>
      </div>
      <p>As basis-function a Lorentzian is assumed with a common width.</p>
<p>Arguments:
1.  file, the result is written in (ascii-table). In addition a graph is created and shown on the fly. This graph is not saved.
2.  number of grid-points to be used for the calculation
3.  line-spectrum list (frequency, intensity) 
4.  broadening constant for the Lorentzians. It is the same for all peaks</p>
<p>All arguments are obligatory."""
out = open(spectfile, "w")
minfreq=linspect[0][np.argmin(linspect[0])] # min-freq   of fluorescence
maxfreq=linspect[0][np.argmax(linspect[0])] # max freq
print'maximal and minimal frequencies:\n', maxfreq, minfreq
minfreq-=1000 #the range should be greater than the transition-frequencies
maxfreq+=1000 
omega=np.linspace(minfreq,maxfreq,gridpt)
spect=np.zeros(len(omega))</p>
<h1>grid=np.zeros(len(omega)) #data-points</h1>
<h1>print grid</h1>
<p>for i in range(len(omega)):
   intens=sum(linspect[1][j]/np.pi<em>gamma/((omega[i]-linspect[0][j])</em>(omega[i]-linspect[0][j])+ gamma*gamma)
  for j in range(len(linspect[0])) )
   out.write(u" '{0}'  '{1}'\n".format(omega[i] ,intens))
   spect[i]=intens
plt.plot(omega, spect)
plt.title('Broadened pectrum of Ir-PS')
plt.xlabel('Frequency [$cm^{-1}$]')
plt.ylabel('Intensity (arb. units)')
plt.show()
out.close()</p>
<p>states(alpha, n):
def unlabeled_balls_in_labeled_boxes(balls, box_sizes): #needed for 'states'</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-73'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-73'>#</a>
      </div>
      <p>def _unlabeled_balls_in_labeled_boxes(balls, box_sizes): #needed for 'unlabeled_balls_in_labeled_boxes' needed for 'states'</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-74'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-74'>#</a>
      </div>
      <pre><code>
     # If there are no balls, all boxes must be empty:
</code></pre>
<p>if not balls:
   yield len(box_sizes) * (0,)</p>
<pre><code>     elif len(box_sizes) == 1:

        # If the single available box has sufficient capacity to store the balls,
</code></pre>
<p># there is only one possible distribution, and we return it to the caller
   # via <code>yield</code>.  Otherwise, the flow of control will pass to the end of the
   # function, triggering a <code>StopIteration</code> exception.
   if box_sizes[0] &gt;= balls:
      yield (balls,)</p>
<pre><code>     else:
</code></pre>
<p># Iterate over the number of balls in the first box (from the maximum
   # possible down to zero), recursively invoking the generator to distribute
   # the remaining balls among the remaining boxes.
   for balls_in_first_box in xrange( min(balls, box_sizes[0]), -1, -1 ):
      balls_in_other_boxes= balls - balls_in_first_box
      for distribution_other in _unlabeled_balls_in_labeled_boxes(
      balls_in_other_boxes, box_sizes[1:]):
  yield (balls_in_first_box,) + distribution_other</p>
<h1>end three alternative blocks</h1>
<pre><code>if not isinstance(balls, int):
    raise TypeError("balls must be a non-negative integer.")
if balls &lt; 0:
     raise ValueError("balls must be a non-negative integer.")

if not isinstance(box_sizes,list):
     raise ValueError("box_sizes must be a non-empty list.")

capacity= 0
for size in box_sizes:
</code></pre>
<p>if not isinstance(size, int):
   raise TypeError("box_sizes must contain only positive integers.")
if size &lt; 1:
   raise ValueError("box_sizes must contain only positive integers.")
capacity+= size</p>
<pre><code>if capacity &lt; balls:
     raise ValueError("The total capacity of the boxes is less than the "
</code></pre>
<p>"number of balls to be distributed.")</p>
<pre><code>return _unlabeled_balls_in_labeled_boxes(balls, box_sizes)
# end def _unlabeled_balls_in_labeled_boxes(balls, box_sizes)
</code></pre>
<p>States=np.zeros((math.factorial(n+alpha-1)/(math.factorial(n)<em>math.factorial(alpha-1)),alpha))
 a=np.ones(alpha).tolist()
 for i in range(len(a)):
    a[i]=n</em>int(a[i]) #create the needed list
 i=0
 for distributions in unlabeled_balls_in_labeled_boxes(n,a):
    States[i]=np.matrix(distributions)
    i+=1
 return States</p>
<p>rsion=2.6
End of functions_smsc.py</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
